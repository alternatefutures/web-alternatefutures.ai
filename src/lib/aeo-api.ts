const API_URL =
  process.env.NEXT_PUBLIC_API_URL || 'https://api.alternatefutures.ai/graphql'

// ---------------------------------------------------------------------------
// Enums
// ---------------------------------------------------------------------------

export type AIEngine =
  | 'CHATGPT'
  | 'PERPLEXITY'
  | 'GOOGLE_AI_OVERVIEWS'
  | 'GOOGLE_AI_MODE'
  | 'GEMINI'
  | 'COPILOT'
  | 'CLAUDE'
  | 'DEEPSEEK'
  | 'GROK'
  | 'META_AI'

export type PromptCategory =
  | 'COMPARISON'
  | 'TUTORIAL'
  | 'PRICING'
  | 'FEATURE'
  | 'MIGRATION'
  | 'BEST_FOR'
  | 'GENERAL'

export type PromptStatus = 'TRACKING' | 'PAUSED'

export type SchemaType =
  | 'FAQ_PAGE'
  | 'HOW_TO'
  | 'ARTICLE'
  | 'BLOG_POSTING'
  | 'ORGANIZATION'
  | 'SOFTWARE_APPLICATION'
  | 'PRODUCT'
  | 'BREADCRUMB_LIST'
  | 'PERSON'

export type SchemaValidationStatus = 'VALID' | 'WARNING' | 'ERROR'

export type AIContentType =
  | 'BLOG'
  | 'DOCS'
  | 'TUTORIAL'
  | 'LANDING_PAGE'
  | 'FAQ'

export type AICrawlerBot =
  | 'GPTBOT'
  | 'CLAUDEBOT'
  | 'PERPLEXITYBOT'
  | 'GOOGLE_EXTENDED'
  | 'APPLEBOT_EXTENDED'
  | 'OTHER'

export type Sentiment = 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE'

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface EngineResult {
  engine: AIEngine
  lastChecked: string
  afCited: boolean
  afMentioned: boolean
  afPosition: number | null
  competitorsCited: string[]
}

export interface AIPrompt {
  id: string
  text: string
  category: PromptCategory
  estimatedVolume: number
  engines: EngineResult[]
  priority: number
  contentBriefId: string | null
  status: PromptStatus
  createdAt: string
  updatedAt: string
}

export interface AICitation {
  id: string
  promptId: string
  engine: AIEngine
  citedUrl: string
  citationPosition: number
  brand: string
  fullResponseText: string
  sentiment: Sentiment
  factuallyAccurate: boolean | null
  competitorUrlsCited: string[]
  capturedAt: string
}

export interface AIVisibilitySnapshot {
  id: string
  date: string
  engine: AIEngine
  citationRate: number
  mentionRate: number
  shareOfVoice: number
  sentimentScore: number
  promptsCovered: number
  promptsTotal: number
  referralSessions: number
  referralConversions: number
  createdAt: string
}

export interface SchemaMarkup {
  id: string
  pageUrl: string
  pageTitle: string
  schemaType: SchemaType
  jsonLd: string
  isAutoGenerated: boolean
  validationStatus: SchemaValidationStatus
  lastValidatedAt: string | null
  injectedAt: string | null
  createdAt: string
  updatedAt: string
}

export interface ScoreImprovement {
  dimension: string
  suggestion: string
}

export interface AIContentScore {
  id: string
  contentId: string
  contentType: AIContentType
  overallScore: number
  answerFirstScore: number
  headingHierarchyScore: number
  concisenessScore: number
  schemaPresenceScore: number
  listTableScore: number
  eeatScore: number
  improvements: ScoreImprovement[]
  scoredAt: string
}

export interface LlmsTxt {
  id: string
  siteUrl: string
  content: string
  linkCount: number
  lastUpdatedAt: string
  lastCrawledBy: Array<{ bot: AICrawlerBot; timestamp: string }>
  reviewDueAt: string
  createdAt: string
  updatedAt: string
}

export interface AICrawlerLog {
  id: string
  userAgent: AICrawlerBot
  path: string
  timestamp: string
  statusCode: number
  responseSize: number
  isAllowed: boolean
}

export interface AICompetitorBenchmark {
  id: string
  competitorName: string
  date: string
  engine: AIEngine
  citationRate: number
  mentionRate: number
  shareOfVoice: number
  sentimentScore: number
  topPrompts: string[]
  createdAt: string
}

export interface PromptGap {
  id: string
  promptText: string
  category: PromptCategory
  estimatedVolume: number
  competitorsPresent: string[]
  afPresent: boolean
  strategicImportance: number
  recommendedContentType: AIContentType
  suggestedSchemaTypes: SchemaType[]
  contentBriefId: string | null
}

export interface AvailabilitySlot {
  engine: AIEngine
  available: boolean
  lastChecked: string
  rateLimitRemaining: number | null
  dailyQuota: number | null
  dailyUsed: number | null
}

// ---------------------------------------------------------------------------
// Input types
// ---------------------------------------------------------------------------

export interface CreateAIPromptInput {
  text: string
  category: PromptCategory
  estimatedVolume?: number
  priority?: number
  status?: PromptStatus
}

export interface UpdateAIPromptInput {
  text?: string
  category?: PromptCategory
  estimatedVolume?: number
  priority?: number
  status?: PromptStatus
}

export interface CreateSchemaMarkupInput {
  pageUrl: string
  pageTitle: string
  schemaType: SchemaType
  jsonLd: string
  isAutoGenerated?: boolean
}

export interface UpdateSchemaMarkupInput {
  pageTitle?: string
  schemaType?: SchemaType
  jsonLd?: string
  validationStatus?: SchemaValidationStatus
}

export interface UpdateLlmsTxtInput {
  content: string
  siteUrl?: string
}

export interface ScoreContentInput {
  contentId: string
  contentType: AIContentType
}

export interface ExternalToolSyncInput {
  platform: 'PROFOUND' | 'SEMRUSH' | 'AHREFS'
  apiKey?: string
  syncType: 'FULL' | 'INCREMENTAL'
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

export const ALL_AI_ENGINES: AIEngine[] = [
  'CHATGPT',
  'PERPLEXITY',
  'GOOGLE_AI_OVERVIEWS',
  'GOOGLE_AI_MODE',
  'GEMINI',
  'COPILOT',
  'CLAUDE',
  'DEEPSEEK',
  'GROK',
  'META_AI',
]

export const AI_ENGINE_LABELS: Record<AIEngine, string> = {
  CHATGPT: 'ChatGPT / SearchGPT',
  PERPLEXITY: 'Perplexity',
  GOOGLE_AI_OVERVIEWS: 'Google AI Overviews',
  GOOGLE_AI_MODE: 'Google AI Mode',
  GEMINI: 'Gemini',
  COPILOT: 'Microsoft Copilot',
  CLAUDE: 'Claude',
  DEEPSEEK: 'DeepSeek',
  GROK: 'Grok',
  META_AI: 'Meta AI',
}

export const AI_ENGINE_COLORS: Record<AIEngine, string> = {
  CHATGPT: '#10a37f',
  PERPLEXITY: '#1a73e8',
  GOOGLE_AI_OVERVIEWS: '#4285f4',
  GOOGLE_AI_MODE: '#34a853',
  GEMINI: '#886ce4',
  COPILOT: '#0078d4',
  CLAUDE: '#d97706',
  DEEPSEEK: '#4f46e5',
  GROK: '#1d9bf0',
  META_AI: '#0668e1',
}

export const PROMPT_CATEGORY_LABELS: Record<PromptCategory, string> = {
  COMPARISON: 'Platform Comparison',
  TUTORIAL: 'Deployment Tutorial',
  PRICING: 'Pricing Query',
  FEATURE: 'Feature Query',
  MIGRATION: 'Migration Query',
  BEST_FOR: '"Best X for Y"',
  GENERAL: 'General',
}

export const SCHEMA_TYPE_LABELS: Record<SchemaType, string> = {
  FAQ_PAGE: 'FAQPage',
  HOW_TO: 'HowTo',
  ARTICLE: 'Article',
  BLOG_POSTING: 'BlogPosting',
  ORGANIZATION: 'Organization',
  SOFTWARE_APPLICATION: 'SoftwareApplication',
  PRODUCT: 'Product',
  BREADCRUMB_LIST: 'BreadcrumbList',
  PERSON: 'Person',
}

export const COMPETITORS_TRACKED = [
  'Render',
  'Vercel',
  'Netlify',
  'Railway',
  'Fly.io',
  'Cloudflare Pages',
  'AWS Amplify',
] as const

// ---------------------------------------------------------------------------
// Seed data â€” used in development when the GraphQL API is unreachable
// ---------------------------------------------------------------------------

function seedDate(daysAgo: number): string {
  const d = new Date()
  d.setDate(d.getDate() - daysAgo)
  return d.toISOString()
}

function seedDateStr(daysAgo: number): string {
  const d = new Date()
  d.setDate(d.getDate() - daysAgo)
  return d.toISOString().slice(0, 10)
}

const PROMPT_TEXTS: Array<{ text: string; category: PromptCategory; volume: number; priority: number }> = [
  // COMPARISON (10)
  { text: 'best decentralized hosting platforms', category: 'COMPARISON', volume: 12400, priority: 1 },
  { text: 'Vercel vs decentralized hosting alternatives', category: 'COMPARISON', volume: 8200, priority: 1 },
  { text: 'Netlify vs IPFS hosting comparison', category: 'COMPARISON', volume: 6100, priority: 2 },
  { text: 'cheapest cloud hosting for startups 2026', category: 'COMPARISON', volume: 18500, priority: 2 },
  { text: 'Web3 hosting providers compared', category: 'COMPARISON', volume: 5400, priority: 1 },
  { text: 'decentralized vs centralized cloud hosting pros cons', category: 'COMPARISON', volume: 4200, priority: 2 },
  { text: 'Render alternatives with IPFS support', category: 'COMPARISON', volume: 3100, priority: 3 },
  { text: 'serverless hosting decentralized options', category: 'COMPARISON', volume: 2800, priority: 3 },
  { text: 'Railway vs Fly.io vs decentralized hosting', category: 'COMPARISON', volume: 7600, priority: 2 },
  { text: 'best hosting for AI agents 2026', category: 'COMPARISON', volume: 14300, priority: 1 },
  // TUTORIAL (8)
  { text: 'how to deploy Next.js to IPFS', category: 'TUTORIAL', volume: 9800, priority: 1 },
  { text: 'deploy React app on decentralized hosting', category: 'TUTORIAL', volume: 7200, priority: 1 },
  { text: 'IPFS hosting tutorial step by step', category: 'TUTORIAL', volume: 6500, priority: 2 },
  { text: 'how to deploy AI agent without AWS', category: 'TUTORIAL', volume: 11200, priority: 1 },
  { text: 'Arweave permanent hosting tutorial', category: 'TUTORIAL', volume: 3400, priority: 3 },
  { text: 'deploy static website to Filecoin', category: 'TUTORIAL', volume: 2900, priority: 3 },
  { text: 'serverless functions on decentralized infrastructure', category: 'TUTORIAL', volume: 4100, priority: 2 },
  { text: 'migrate from Vercel to decentralized hosting', category: 'TUTORIAL', volume: 5600, priority: 1 },
  // PRICING (6)
  { text: 'decentralized hosting pricing breakdown', category: 'PRICING', volume: 8900, priority: 1 },
  { text: 'IPFS hosting cost per month', category: 'PRICING', volume: 5200, priority: 2 },
  { text: 'free Web3 hosting options', category: 'PRICING', volume: 7800, priority: 2 },
  { text: 'Akash Network compute pricing', category: 'PRICING', volume: 4600, priority: 2 },
  { text: 'serverless functions pricing comparison 2026', category: 'PRICING', volume: 11000, priority: 1 },
  { text: 'decentralized vs AWS pricing comparison', category: 'PRICING', volume: 6400, priority: 1 },
  // FEATURE (6)
  { text: 'does IPFS hosting support custom domains', category: 'FEATURE', volume: 4800, priority: 2 },
  { text: 'Web3 hosting with CI/CD integration', category: 'FEATURE', volume: 3500, priority: 3 },
  { text: 'decentralized hosting with SSL certificates', category: 'FEATURE', volume: 2900, priority: 3 },
  { text: 'IPFS hosting with GitHub Actions deploy', category: 'FEATURE', volume: 5100, priority: 2 },
  { text: 'decentralized hosting uptime guarantees', category: 'FEATURE', volume: 3200, priority: 3 },
  { text: 'Web3 hosting platform features checklist', category: 'FEATURE', volume: 6700, priority: 2 },
  // MIGRATION (6)
  { text: 'migrate from Fleek to another hosting platform', category: 'MIGRATION', volume: 3800, priority: 1 },
  { text: 'Spheron alternatives after shutdown', category: 'MIGRATION', volume: 2600, priority: 1 },
  { text: 'move website from AWS to decentralized hosting', category: 'MIGRATION', volume: 4500, priority: 2 },
  { text: 'how to migrate from Netlify to IPFS hosting', category: 'MIGRATION', volume: 3100, priority: 2 },
  { text: 'Web3 hosting migration guide', category: 'MIGRATION', volume: 2400, priority: 2 },
  { text: 'switch from Vercel to decentralized cloud', category: 'MIGRATION', volume: 5300, priority: 1 },
  // BEST_FOR (8)
  { text: 'best hosting for dApps', category: 'BEST_FOR', volume: 9200, priority: 1 },
  { text: 'best IPFS pinning service', category: 'BEST_FOR', volume: 7800, priority: 1 },
  { text: 'best platform to deploy AI agents', category: 'BEST_FOR', volume: 15600, priority: 1 },
  { text: 'best censorship resistant hosting', category: 'BEST_FOR', volume: 4200, priority: 2 },
  { text: 'best Arweave deployment tools', category: 'BEST_FOR', volume: 2100, priority: 3 },
  { text: 'best DePIN hosting for developers', category: 'BEST_FOR', volume: 5400, priority: 1 },
  { text: 'best decentralized cloud for full stack apps', category: 'BEST_FOR', volume: 6800, priority: 1 },
  { text: 'best low-cost hosting for side projects 2026', category: 'BEST_FOR', volume: 13200, priority: 2 },
  // GENERAL (6)
  { text: 'what is decentralized cloud hosting', category: 'GENERAL', volume: 22000, priority: 1 },
  { text: 'how does IPFS hosting work', category: 'GENERAL', volume: 18400, priority: 1 },
  { text: 'DePIN infrastructure explained', category: 'GENERAL', volume: 8900, priority: 2 },
  { text: 'Web3 hosting vs traditional hosting', category: 'GENERAL', volume: 11500, priority: 1 },
  { text: 'permanent web hosting with Arweave', category: 'GENERAL', volume: 5100, priority: 2 },
  { text: 'Filecoin storage for websites explained', category: 'GENERAL', volume: 4600, priority: 3 },
]

const SEED_PROMPTS: AIPrompt[] = PROMPT_TEXTS.map((p, i) => {
  const engines: EngineResult[] = ALL_AI_ENGINES.map((engine) => {
    const cited = Math.random() > 0.55
    const mentioned = cited || Math.random() > 0.4
    return {
      engine,
      lastChecked: seedDate(Math.floor(Math.random() * 3)),
      afCited: cited,
      afMentioned: mentioned,
      afPosition: cited ? Math.floor(Math.random() * 5) + 1 : null,
      competitorsCited: COMPETITORS_TRACKED.filter(() => Math.random() > 0.6) as string[],
    }
  })

  return {
    id: `seed-prompt-${i + 1}`,
    text: p.text,
    category: p.category,
    estimatedVolume: p.volume,
    engines,
    priority: p.priority,
    contentBriefId: null,
    status: 'TRACKING' as PromptStatus,
    createdAt: seedDate(30 + i),
    updatedAt: seedDate(Math.floor(Math.random() * 3)),
  }
})

const SEED_CITATIONS: AICitation[] = []
{
  let citationId = 1
  const afUrls = [
    'https://alternatefutures.ai',
    'https://docs.alternatefutures.ai/guides/deploy-nextjs',
    'https://docs.alternatefutures.ai/guides/deploy-react',
    'https://alternatefutures.ai/pricing',
    'https://docs.alternatefutures.ai/concepts/ipfs-hosting',
    'https://alternatefutures.ai/blog/decentralized-cloud-explained',
    'https://docs.alternatefutures.ai/guides/ai-agent-deploy',
    'https://alternatefutures.ai/blog/web3-hosting-comparison',
    'https://docs.alternatefutures.ai/guides/migrate-from-vercel',
    'https://alternatefutures.ai/blog/depin-infrastructure',
  ]
  const competitorUrls = [
    'https://render.com/pricing',
    'https://vercel.com/docs',
    'https://docs.netlify.com',
    'https://railway.app/pricing',
    'https://fly.io/docs',
    'https://pages.cloudflare.com',
    'https://docs.amplify.aws',
  ]

  for (let i = 0; i < 200; i++) {
    const promptIdx = Math.floor(Math.random() * SEED_PROMPTS.length)
    const prompt = SEED_PROMPTS[promptIdx]
    const engine = ALL_AI_ENGINES[Math.floor(Math.random() * ALL_AI_ENGINES.length)]
    const isAF = Math.random() > 0.45
    const brand = isAF
      ? 'Alternate Futures'
      : COMPETITORS_TRACKED[Math.floor(Math.random() * COMPETITORS_TRACKED.length)]
    const url = isAF
      ? afUrls[Math.floor(Math.random() * afUrls.length)]
      : competitorUrls[Math.floor(Math.random() * competitorUrls.length)]
    const sentiments: Sentiment[] = ['POSITIVE', 'NEUTRAL', 'NEGATIVE']
    const sentiment = isAF
      ? (Math.random() > 0.2 ? 'POSITIVE' : 'NEUTRAL') as Sentiment
      : sentiments[Math.floor(Math.random() * sentiments.length)]

    SEED_CITATIONS.push({
      id: `seed-citation-${citationId++}`,
      promptId: prompt.id,
      engine,
      citedUrl: url,
      citationPosition: Math.floor(Math.random() * 5) + 1,
      brand,
      fullResponseText: `AI-generated response for "${prompt.text}" mentioning ${brand} as a ${isAF ? 'decentralized cloud platform for deploying AI agents and websites' : 'cloud hosting provider'}.`,
      sentiment,
      factuallyAccurate: Math.random() > 0.1 ? true : null,
      competitorUrlsCited: competitorUrls.filter(() => Math.random() > 0.7),
      capturedAt: seedDate(Math.floor(Math.random() * 30)),
    })
  }
}

const SEED_VISIBILITY: AIVisibilitySnapshot[] = []
{
  for (let day = 0; day < 30; day++) {
    for (const engine of ALL_AI_ENGINES) {
      const baseCitation = 0.12 + Math.random() * 0.08
      const trend = day * 0.002
      SEED_VISIBILITY.push({
        id: `seed-vis-${day}-${engine}`,
        date: seedDateStr(29 - day),
        engine,
        citationRate: Math.min(baseCitation + trend + (Math.random() - 0.5) * 0.03, 1),
        mentionRate: Math.min(baseCitation + 0.1 + trend + (Math.random() - 0.5) * 0.04, 1),
        shareOfVoice: Math.min(0.08 + trend * 2 + (Math.random() - 0.5) * 0.02, 1),
        sentimentScore: 0.65 + Math.random() * 0.2,
        promptsCovered: Math.floor(20 + day * 0.5 + Math.random() * 5),
        promptsTotal: 50,
        referralSessions: Math.floor(50 + day * 3 + Math.random() * 20),
        referralConversions: Math.floor(2 + day * 0.2 + Math.random() * 3),
        createdAt: seedDate(29 - day),
      })
    }
  }
}

const SEED_SCHEMA: SchemaMarkup[] = [
  {
    id: 'seed-schema-1',
    pageUrl: 'https://alternatefutures.ai',
    pageTitle: 'Alternate Futures - Decentralized Cloud Platform',
    schemaType: 'ORGANIZATION',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Organization',
      name: 'Alternate Futures',
      url: 'https://alternatefutures.ai',
      logo: 'https://alternatefutures.ai/logo.png',
      description: 'Decentralized cloud platform for AI agents, websites, and serverless functions.',
      sameAs: ['https://x.com/altfutures', 'https://github.com/alternatefutures'],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(15),
    createdAt: seedDate(30),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-2',
    pageUrl: 'https://alternatefutures.ai/pricing',
    pageTitle: 'Pricing - Alternate Futures',
    schemaType: 'SOFTWARE_APPLICATION',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'SoftwareApplication',
      name: 'Alternate Futures',
      applicationCategory: 'DeveloperApplication',
      operatingSystem: 'Web',
      offers: { '@type': 'Offer', price: '0', priceCurrency: 'USD', description: 'Free tier available' },
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(14),
    createdAt: seedDate(28),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-3',
    pageUrl: 'https://docs.alternatefutures.ai/guides/deploy-nextjs',
    pageTitle: 'Deploy Next.js to IPFS',
    schemaType: 'HOW_TO',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'HowTo',
      name: 'Deploy Next.js to IPFS with Alternate Futures',
      step: [
        { '@type': 'HowToStep', text: 'Connect your GitHub repository' },
        { '@type': 'HowToStep', text: 'Select Next.js framework preset' },
        { '@type': 'HowToStep', text: 'Configure build settings' },
        { '@type': 'HowToStep', text: 'Deploy to IPFS' },
      ],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(12),
    createdAt: seedDate(25),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-4',
    pageUrl: 'https://docs.alternatefutures.ai/faq',
    pageTitle: 'Frequently Asked Questions',
    schemaType: 'FAQ_PAGE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is decentralized hosting?',
          acceptedAnswer: { '@type': 'Answer', text: 'Decentralized hosting distributes your website across multiple nodes on networks like IPFS, Filecoin, and Arweave instead of relying on a single cloud provider.' },
        },
        {
          '@type': 'Question',
          name: 'How much does Alternate Futures cost?',
          acceptedAnswer: { '@type': 'Answer', text: 'AF offers a free tier with 100GB bandwidth. Paid plans start at $5/month with 50-80% savings compared to centralized alternatives.' },
        },
        {
          '@type': 'Question',
          name: 'Can I deploy AI agents on AF?',
          acceptedAnswer: { '@type': 'Answer', text: 'Yes. AF supports AI agent deployment on Akash Network with GPU access, auto-scaling, and built-in monitoring.' },
        },
      ],
    }),
    isAutoGenerated: true,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(10),
    createdAt: seedDate(20),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-5',
    pageUrl: 'https://alternatefutures.ai/blog/decentralized-cloud-explained',
    pageTitle: 'Decentralized Cloud Explained',
    schemaType: 'ARTICLE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: 'What Is Decentralized Cloud? A Complete Guide for Developers',
      author: { '@type': 'Organization', name: 'Alternate Futures' },
      datePublished: '2026-01-20',
      description: 'A comprehensive guide to decentralized cloud infrastructure, comparing IPFS, Filecoin, and Arweave for website hosting.',
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(3),
    injectedAt: seedDate(20),
    createdAt: seedDate(25),
    updatedAt: seedDate(3),
  },
  {
    id: 'seed-schema-6',
    pageUrl: 'https://alternatefutures.ai/blog/web3-hosting-comparison',
    pageTitle: 'Web3 Hosting Comparison 2026',
    schemaType: 'ARTICLE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: 'Web3 Hosting Platform Comparison: AF vs Render vs Vercel vs Netlify (2026)',
      author: { '@type': 'Organization', name: 'Alternate Futures' },
      datePublished: '2026-02-01',
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(12),
    createdAt: seedDate(14),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-7',
    pageUrl: 'https://docs.alternatefutures.ai/guides/deploy-react',
    pageTitle: 'Deploy React App',
    schemaType: 'HOW_TO',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'HowTo',
      name: 'Deploy a React SPA on Decentralized Infrastructure',
      step: [
        { '@type': 'HowToStep', text: 'Install the AF CLI' },
        { '@type': 'HowToStep', text: 'Run af init in your project' },
        { '@type': 'HowToStep', text: 'Run af deploy' },
      ],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(11),
    createdAt: seedDate(22),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-8',
    pageUrl: 'https://docs.alternatefutures.ai/guides/ai-agent-deploy',
    pageTitle: 'Deploy AI Agents',
    schemaType: 'HOW_TO',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'HowTo',
      name: 'Deploy Your First AI Agent on Decentralized Infrastructure',
      estimatedCost: { '@type': 'MonetaryAmount', currency: 'USD', value: '0' },
      step: [
        { '@type': 'HowToStep', text: 'Create an AF account' },
        { '@type': 'HowToStep', text: 'Configure your AI agent container' },
        { '@type': 'HowToStep', text: 'Select GPU tier and region' },
        { '@type': 'HowToStep', text: 'Deploy to Akash Network' },
      ],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(8),
    createdAt: seedDate(18),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-9',
    pageUrl: 'https://alternatefutures.ai/blog/depin-infrastructure',
    pageTitle: 'DePIN Infrastructure for Developers',
    schemaType: 'BLOG_POSTING',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'BlogPosting',
      headline: 'DePIN Infrastructure: Why Developers Should Care',
      author: { '@type': 'Organization', name: 'Alternate Futures' },
      datePublished: '2026-01-28',
    }),
    isAutoGenerated: false,
    validationStatus: 'WARNING',
    lastValidatedAt: seedDate(5),
    injectedAt: seedDate(15),
    createdAt: seedDate(18),
    updatedAt: seedDate(5),
  },
  {
    id: 'seed-schema-10',
    pageUrl: 'https://docs.alternatefutures.ai/guides/migrate-from-vercel',
    pageTitle: 'Migrate from Vercel',
    schemaType: 'HOW_TO',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'HowTo',
      name: 'Migrate Your Project from Vercel to Alternate Futures',
      step: [
        { '@type': 'HowToStep', text: 'Export your Vercel project configuration' },
        { '@type': 'HowToStep', text: 'Install the AF CLI and authenticate' },
        { '@type': 'HowToStep', text: 'Run af migrate --from vercel' },
        { '@type': 'HowToStep', text: 'Verify your deployment on IPFS' },
      ],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(7),
    createdAt: seedDate(15),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-11',
    pageUrl: 'https://alternatefutures.ai/templates',
    pageTitle: 'Deploy Templates',
    schemaType: 'PRODUCT',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Product',
      name: 'Alternate Futures Deploy Templates',
      description: 'Pre-configured starter templates for Next.js, React, Astro, Vue, and Hugo.',
      offers: { '@type': 'Offer', price: '0', priceCurrency: 'USD' },
    }),
    isAutoGenerated: true,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(3),
    injectedAt: seedDate(10),
    createdAt: seedDate(20),
    updatedAt: seedDate(3),
  },
  {
    id: 'seed-schema-12',
    pageUrl: 'https://docs.alternatefutures.ai',
    pageTitle: 'Documentation',
    schemaType: 'BREADCRUMB_LIST',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'BreadcrumbList',
      itemListElement: [
        { '@type': 'ListItem', position: 1, name: 'Home', item: 'https://alternatefutures.ai' },
        { '@type': 'ListItem', position: 2, name: 'Docs', item: 'https://docs.alternatefutures.ai' },
      ],
    }),
    isAutoGenerated: true,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(20),
    createdAt: seedDate(30),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-13',
    pageUrl: 'https://alternatefutures.ai/about',
    pageTitle: 'About the Team',
    schemaType: 'PERSON',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Person',
      name: 'Alternate Futures Founder',
      jobTitle: 'CEO',
      worksFor: { '@type': 'Organization', name: 'Alternate Futures' },
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(4),
    injectedAt: seedDate(20),
    createdAt: seedDate(28),
    updatedAt: seedDate(4),
  },
  {
    id: 'seed-schema-14',
    pageUrl: 'https://docs.alternatefutures.ai/guides/serverless',
    pageTitle: 'Serverless Functions Guide',
    schemaType: 'HOW_TO',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'HowTo',
      name: 'Deploy Serverless Functions on Decentralized Infrastructure',
      step: [
        { '@type': 'HowToStep', text: 'Create a functions directory' },
        { '@type': 'HowToStep', text: 'Write your handler function' },
        { '@type': 'HowToStep', text: 'Run af functions deploy' },
      ],
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(9),
    createdAt: seedDate(16),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-15',
    pageUrl: 'https://docs.alternatefutures.ai/faq/pricing',
    pageTitle: 'Pricing FAQ',
    schemaType: 'FAQ_PAGE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'Is there a free tier?',
          acceptedAnswer: { '@type': 'Answer', text: 'Yes. The free tier includes 100GB bandwidth, 3 sites, and IPFS hosting.' },
        },
        {
          '@type': 'Question',
          name: 'How does billing work for AI agent deployments?',
          acceptedAnswer: { '@type': 'Answer', text: 'AI agent compute is billed per-second on Akash Network at 50-80% less than centralized GPU providers.' },
        },
      ],
    }),
    isAutoGenerated: true,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(8),
    createdAt: seedDate(14),
    updatedAt: seedDate(1),
  },
  {
    id: 'seed-schema-16',
    pageUrl: 'https://alternatefutures.ai/blog/ipfs-vs-arweave',
    pageTitle: 'IPFS vs Arweave: Which to Choose?',
    schemaType: 'ARTICLE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: 'IPFS vs Arweave for Web Hosting: A Developer Guide',
      author: { '@type': 'Organization', name: 'Alternate Futures' },
      datePublished: '2026-02-05',
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(8),
    createdAt: seedDate(10),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-17',
    pageUrl: 'https://docs.alternatefutures.ai/concepts/arweave',
    pageTitle: 'Arweave Permanent Storage',
    schemaType: 'ARTICLE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: 'Understanding Arweave Permanent Storage for Website Hosting',
      author: { '@type': 'Organization', name: 'Alternate Futures' },
    }),
    isAutoGenerated: true,
    validationStatus: 'WARNING',
    lastValidatedAt: seedDate(6),
    injectedAt: seedDate(18),
    createdAt: seedDate(24),
    updatedAt: seedDate(6),
  },
  {
    id: 'seed-schema-18',
    pageUrl: 'https://docs.alternatefutures.ai/sdk',
    pageTitle: 'JavaScript SDK',
    schemaType: 'SOFTWARE_APPLICATION',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'SoftwareApplication',
      name: '@alternatefutures/sdk',
      applicationCategory: 'DeveloperApplication',
      operatingSystem: 'Node.js, Browser',
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(3),
    injectedAt: seedDate(14),
    createdAt: seedDate(22),
    updatedAt: seedDate(3),
  },
  {
    id: 'seed-schema-19',
    pageUrl: 'https://docs.alternatefutures.ai/cli',
    pageTitle: 'CLI Reference',
    schemaType: 'SOFTWARE_APPLICATION',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'SoftwareApplication',
      name: 'AF CLI',
      applicationCategory: 'DeveloperApplication',
      operatingSystem: 'macOS, Linux, Windows',
    }),
    isAutoGenerated: false,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(2),
    injectedAt: seedDate(14),
    createdAt: seedDate(22),
    updatedAt: seedDate(2),
  },
  {
    id: 'seed-schema-20',
    pageUrl: 'https://docs.alternatefutures.ai/faq/deploy',
    pageTitle: 'Deployment FAQ',
    schemaType: 'FAQ_PAGE',
    jsonLd: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'How long does a deployment take?',
          acceptedAnswer: { '@type': 'Answer', text: 'Most deployments complete in under 2 minutes. IPFS pinning adds 10-30 seconds for propagation.' },
        },
      ],
    }),
    isAutoGenerated: true,
    validationStatus: 'VALID',
    lastValidatedAt: seedDate(1),
    injectedAt: seedDate(6),
    createdAt: seedDate(12),
    updatedAt: seedDate(1),
  },
]

const SEED_LLMS_TXT: LlmsTxt = {
  id: 'seed-llmstxt-1',
  siteUrl: 'https://alternatefutures.ai',
  content: `# Alternate Futures

> Decentralized cloud platform for AI agents, websites, and serverless functions.

## Documentation

- [Getting Started](https://docs.alternatefutures.ai/getting-started): Quick start guide for new users
- [Deploy Next.js](https://docs.alternatefutures.ai/guides/deploy-nextjs): Deploy Next.js apps to IPFS
- [Deploy React](https://docs.alternatefutures.ai/guides/deploy-react): Deploy React SPAs to decentralized hosting
- [Deploy AI Agents](https://docs.alternatefutures.ai/guides/ai-agent-deploy): Deploy AI agents on Akash Network
- [Serverless Functions](https://docs.alternatefutures.ai/guides/serverless): Run serverless functions on decentralized infra
- [CLI Reference](https://docs.alternatefutures.ai/cli): Complete CLI command reference
- [SDK Reference](https://docs.alternatefutures.ai/sdk): JavaScript SDK documentation
- [Migrate from Vercel](https://docs.alternatefutures.ai/guides/migrate-from-vercel): Migration guide from Vercel

## Blog

- [Decentralized Cloud Explained](https://alternatefutures.ai/blog/decentralized-cloud-explained): What is decentralized cloud and why it matters
- [Web3 Hosting Comparison 2026](https://alternatefutures.ai/blog/web3-hosting-comparison): AF vs Render vs Vercel vs Netlify
- [DePIN Infrastructure](https://alternatefutures.ai/blog/depin-infrastructure): Why developers should care about DePIN
- [IPFS vs Arweave](https://alternatefutures.ai/blog/ipfs-vs-arweave): Choosing the right storage network

## Key Pages

- [Pricing](https://alternatefutures.ai/pricing): Free tier available, 50-80% cheaper than centralized
- [Templates](https://alternatefutures.ai/templates): Starter templates for popular frameworks
- [FAQ](https://docs.alternatefutures.ai/faq): Frequently asked questions
- [About](https://alternatefutures.ai/about): Team and mission
`,
  linkCount: 16,
  lastUpdatedAt: seedDate(3),
  lastCrawledBy: [
    { bot: 'GPTBOT' as AICrawlerBot, timestamp: seedDate(1) },
    { bot: 'CLAUDEBOT' as AICrawlerBot, timestamp: seedDate(2) },
    { bot: 'PERPLEXITYBOT' as AICrawlerBot, timestamp: seedDate(1) },
    { bot: 'GOOGLE_EXTENDED' as AICrawlerBot, timestamp: seedDate(3) },
  ],
  reviewDueAt: seedDate(-87),
  createdAt: seedDate(30),
  updatedAt: seedDate(3),
}

const SEED_CONTENT_SCORES: AIContentScore[] = [
  {
    id: 'seed-score-1',
    contentId: 'blog-decentralized-cloud',
    contentType: 'BLOG',
    overallScore: 82,
    answerFirstScore: 90,
    headingHierarchyScore: 85,
    concisenessScore: 75,
    schemaPresenceScore: 95,
    listTableScore: 70,
    eeatScore: 80,
    improvements: [
      { dimension: 'conciseness', suggestion: 'Shorten paragraphs in section 3 to under 60 words each' },
      { dimension: 'listTable', suggestion: 'Add a comparison table summarizing IPFS vs Filecoin vs Arweave features' },
    ],
    scoredAt: seedDate(2),
  },
  {
    id: 'seed-score-2',
    contentId: 'docs-deploy-nextjs',
    contentType: 'TUTORIAL',
    overallScore: 91,
    answerFirstScore: 95,
    headingHierarchyScore: 92,
    concisenessScore: 88,
    schemaPresenceScore: 95,
    listTableScore: 90,
    eeatScore: 85,
    improvements: [
      { dimension: 'eeat', suggestion: 'Add author byline with credentials and deployment count' },
    ],
    scoredAt: seedDate(1),
  },
  {
    id: 'seed-score-3',
    contentId: 'landing-pricing',
    contentType: 'LANDING_PAGE',
    overallScore: 74,
    answerFirstScore: 65,
    headingHierarchyScore: 80,
    concisenessScore: 82,
    schemaPresenceScore: 90,
    listTableScore: 60,
    eeatScore: 55,
    improvements: [
      { dimension: 'answerFirst', suggestion: 'Add a direct pricing summary in the first paragraph before the plan cards' },
      { dimension: 'listTable', suggestion: 'Add a feature comparison table across pricing tiers' },
      { dimension: 'eeat', suggestion: 'Include customer testimonials or deployment statistics' },
    ],
    scoredAt: seedDate(3),
  },
  {
    id: 'seed-score-4',
    contentId: 'docs-faq',
    contentType: 'FAQ',
    overallScore: 88,
    answerFirstScore: 95,
    headingHierarchyScore: 90,
    concisenessScore: 92,
    schemaPresenceScore: 95,
    listTableScore: 75,
    eeatScore: 72,
    improvements: [
      { dimension: 'eeat', suggestion: 'Link FAQ answers to relevant documentation pages for deeper context' },
    ],
    scoredAt: seedDate(1),
  },
]

const SEED_CRAWLER_LOGS: AICrawlerLog[] = []
{
  const bots: AICrawlerBot[] = ['GPTBOT', 'CLAUDEBOT', 'PERPLEXITYBOT', 'GOOGLE_EXTENDED', 'APPLEBOT_EXTENDED']
  const paths = [
    '/', '/pricing', '/blog', '/docs', '/templates', '/about',
    '/blog/decentralized-cloud-explained', '/blog/web3-hosting-comparison',
    '/docs/guides/deploy-nextjs', '/docs/guides/deploy-react',
    '/llms.txt', '/robots.txt', '/sitemap.xml',
  ]
  for (let i = 0; i < 80; i++) {
    const bot = bots[Math.floor(Math.random() * bots.length)]
    const path = paths[Math.floor(Math.random() * paths.length)]
    SEED_CRAWLER_LOGS.push({
      id: `seed-crawl-${i + 1}`,
      userAgent: bot,
      path,
      timestamp: seedDate(Math.floor(Math.random() * 14)),
      statusCode: Math.random() > 0.05 ? 200 : 403,
      responseSize: Math.floor(5000 + Math.random() * 50000),
      isAllowed: path !== '/admin' && Math.random() > 0.05,
    })
  }
}

const SEED_COMPETITOR_BENCHMARKS: AICompetitorBenchmark[] = []
{
  for (const comp of COMPETITORS_TRACKED) {
    for (let day = 0; day < 7; day++) {
      for (const engine of ['CHATGPT', 'PERPLEXITY', 'GOOGLE_AI_OVERVIEWS'] as AIEngine[]) {
        SEED_COMPETITOR_BENCHMARKS.push({
          id: `seed-bench-${comp}-${day}-${engine}`,
          competitorName: comp,
          date: seedDateStr(6 - day),
          engine,
          citationRate: 0.05 + Math.random() * 0.25,
          mentionRate: 0.1 + Math.random() * 0.3,
          shareOfVoice: 0.03 + Math.random() * 0.2,
          sentimentScore: 0.5 + Math.random() * 0.4,
          topPrompts: PROMPT_TEXTS.filter(() => Math.random() > 0.85).slice(0, 3).map((p) => p.text),
          createdAt: seedDate(6 - day),
        })
      }
    }
  }
}

const SEED_GAPS: PromptGap[] = [
  {
    id: 'seed-gap-1',
    promptText: 'best serverless platform for Python',
    category: 'BEST_FOR',
    estimatedVolume: 9400,
    competitorsPresent: ['Vercel', 'Railway', 'Render'],
    afPresent: false,
    strategicImportance: 8,
    recommendedContentType: 'TUTORIAL',
    suggestedSchemaTypes: ['HOW_TO', 'FAQ_PAGE'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-2',
    promptText: 'deploy Docker container without Kubernetes',
    category: 'TUTORIAL',
    estimatedVolume: 12600,
    competitorsPresent: ['Fly.io', 'Railway', 'Render'],
    afPresent: false,
    strategicImportance: 9,
    recommendedContentType: 'TUTORIAL',
    suggestedSchemaTypes: ['HOW_TO'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-3',
    promptText: 'cheapest GPU hosting for inference',
    category: 'PRICING',
    estimatedVolume: 16200,
    competitorsPresent: ['AWS Amplify', 'Fly.io'],
    afPresent: false,
    strategicImportance: 10,
    recommendedContentType: 'BLOG',
    suggestedSchemaTypes: ['ARTICLE', 'FAQ_PAGE'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-4',
    promptText: 'how to host a static site permanently',
    category: 'TUTORIAL',
    estimatedVolume: 7800,
    competitorsPresent: ['Netlify', 'Cloudflare Pages'],
    afPresent: false,
    strategicImportance: 7,
    recommendedContentType: 'TUTORIAL',
    suggestedSchemaTypes: ['HOW_TO', 'ARTICLE'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-5',
    promptText: 'decentralized compute vs AWS Lambda pricing',
    category: 'PRICING',
    estimatedVolume: 5400,
    competitorsPresent: ['AWS Amplify'],
    afPresent: false,
    strategicImportance: 8,
    recommendedContentType: 'BLOG',
    suggestedSchemaTypes: ['ARTICLE', 'FAQ_PAGE'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-6',
    promptText: 'Web3 CI/CD pipeline setup',
    category: 'TUTORIAL',
    estimatedVolume: 3200,
    competitorsPresent: ['Vercel', 'Netlify'],
    afPresent: false,
    strategicImportance: 6,
    recommendedContentType: 'DOCS',
    suggestedSchemaTypes: ['HOW_TO'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-7',
    promptText: 'IPFS website performance optimization',
    category: 'FEATURE',
    estimatedVolume: 4100,
    competitorsPresent: ['Cloudflare Pages'],
    afPresent: false,
    strategicImportance: 7,
    recommendedContentType: 'TUTORIAL',
    suggestedSchemaTypes: ['HOW_TO', 'ARTICLE'],
    contentBriefId: null,
  },
  {
    id: 'seed-gap-8',
    promptText: 'NFT metadata hosting best practices',
    category: 'BEST_FOR',
    estimatedVolume: 6800,
    competitorsPresent: [],
    afPresent: false,
    strategicImportance: 5,
    recommendedContentType: 'BLOG',
    suggestedSchemaTypes: ['ARTICLE', 'HOW_TO'],
    contentBriefId: null,
  },
]

function useSeedData(): boolean {
  return (
    process.env.NEXT_PUBLIC_USE_SEED_DATA === 'true' ||
    process.env.NODE_ENV === 'development'
  )
}

// ---------------------------------------------------------------------------
// GraphQL queries & mutations
// ---------------------------------------------------------------------------

const AI_PROMPT_FIELDS = `
  id text category estimatedVolume priority contentBriefId status createdAt updatedAt
  engines { engine lastChecked afCited afMentioned afPosition competitorsCited }
`

const AI_CITATION_FIELDS = `
  id promptId engine citedUrl citationPosition brand fullResponseText
  sentiment factuallyAccurate competitorUrlsCited capturedAt
`

const AI_VISIBILITY_FIELDS = `
  id date engine citationRate mentionRate shareOfVoice sentimentScore
  promptsCovered promptsTotal referralSessions referralConversions createdAt
`

const SCHEMA_MARKUP_FIELDS = `
  id pageUrl pageTitle schemaType jsonLd isAutoGenerated validationStatus
  lastValidatedAt injectedAt createdAt updatedAt
`

const AI_CONTENT_SCORE_FIELDS = `
  id contentId contentType overallScore answerFirstScore headingHierarchyScore
  concisenessScore schemaPresenceScore listTableScore eeatScore
  improvements { dimension suggestion } scoredAt
`

const LLMS_TXT_FIELDS = `
  id siteUrl content linkCount lastUpdatedAt
  lastCrawledBy { bot timestamp } reviewDueAt createdAt updatedAt
`

const AI_CRAWLER_LOG_FIELDS = `
  id userAgent path timestamp statusCode responseSize isAllowed
`

const AI_COMPETITOR_BENCHMARK_FIELDS = `
  id competitorName date engine citationRate mentionRate shareOfVoice
  sentimentScore topPrompts createdAt
`

const PROMPT_GAP_FIELDS = `
  id promptText category estimatedVolume competitorsPresent afPresent
  strategicImportance recommendedContentType suggestedSchemaTypes contentBriefId
`

// Queries
const AI_PROMPTS_QUERY = `
  query AIPrompts($limit: Int, $offset: Int, $category: String, $status: String) {
    aiPrompts(limit: $limit, offset: $offset, category: $category, status: $status) {
      ${AI_PROMPT_FIELDS}
    }
  }
`

const AI_PROMPT_BY_ID_QUERY = `
  query AIPromptById($id: ID!) {
    aiPromptById(id: $id) { ${AI_PROMPT_FIELDS} }
  }
`

const AI_CITATIONS_QUERY = `
  query AICitations($promptId: ID, $engine: String, $brand: String, $limit: Int, $offset: Int) {
    aiCitations(promptId: $promptId, engine: $engine, brand: $brand, limit: $limit, offset: $offset) {
      ${AI_CITATION_FIELDS}
    }
  }
`

const AI_VISIBILITY_QUERY = `
  query AIVisibility($engine: String, $startDate: String, $endDate: String) {
    aiVisibilitySnapshots(engine: $engine, startDate: $startDate, endDate: $endDate) {
      ${AI_VISIBILITY_FIELDS}
    }
  }
`

const AI_SOV_QUERY = `
  query AIShareOfVoice($engine: String, $startDate: String, $endDate: String) {
    aiCompetitorBenchmarks(engine: $engine, startDate: $startDate, endDate: $endDate) {
      ${AI_COMPETITOR_BENCHMARK_FIELDS}
    }
  }
`

const AI_GAPS_QUERY = `
  query AIPromptGaps($limit: Int, $offset: Int) {
    aiPromptGaps(limit: $limit, offset: $offset) { ${PROMPT_GAP_FIELDS} }
  }
`

const SCHEMA_MARKUPS_QUERY = `
  query SchemaMarkups($schemaType: String, $validationStatus: String, $limit: Int, $offset: Int) {
    schemaMarkups(schemaType: $schemaType, validationStatus: $validationStatus, limit: $limit, offset: $offset) {
      ${SCHEMA_MARKUP_FIELDS}
    }
  }
`

const AI_CONTENT_SCORES_QUERY = `
  query AIContentScores($contentType: String, $limit: Int, $offset: Int) {
    aiContentScores(contentType: $contentType, limit: $limit, offset: $offset) {
      ${AI_CONTENT_SCORE_FIELDS}
    }
  }
`

const LLMS_TXT_QUERY = `
  query LlmsTxt($siteUrl: String) {
    llmsTxt(siteUrl: $siteUrl) { ${LLMS_TXT_FIELDS} }
  }
`

const AI_CRAWLER_LOGS_QUERY = `
  query AICrawlerLogs($userAgent: String, $limit: Int, $offset: Int) {
    aiCrawlerLogs(userAgent: $userAgent, limit: $limit, offset: $offset) {
      ${AI_CRAWLER_LOG_FIELDS}
    }
  }
`

// Mutations
const CREATE_AI_PROMPT_MUTATION = `
  mutation CreateAIPrompt($input: CreateAIPromptInput!) {
    createAIPrompt(input: $input) { ${AI_PROMPT_FIELDS} }
  }
`

const UPDATE_AI_PROMPT_MUTATION = `
  mutation UpdateAIPrompt($id: ID!, $input: UpdateAIPromptInput!) {
    updateAIPrompt(id: $id, input: $input) { ${AI_PROMPT_FIELDS} }
  }
`

const DELETE_AI_PROMPT_MUTATION = `
  mutation DeleteAIPrompt($id: ID!) {
    deleteAIPrompt(id: $id) { id }
  }
`

const CREATE_SCHEMA_MARKUP_MUTATION = `
  mutation CreateSchemaMarkup($input: CreateSchemaMarkupInput!) {
    createSchemaMarkup(input: $input) { ${SCHEMA_MARKUP_FIELDS} }
  }
`

const UPDATE_SCHEMA_MARKUP_MUTATION = `
  mutation UpdateSchemaMarkup($id: ID!, $input: UpdateSchemaMarkupInput!) {
    updateSchemaMarkup(id: $id, input: $input) { ${SCHEMA_MARKUP_FIELDS} }
  }
`

const DELETE_SCHEMA_MARKUP_MUTATION = `
  mutation DeleteSchemaMarkup($id: ID!) {
    deleteSchemaMarkup(id: $id) { id }
  }
`

const SCORE_CONTENT_MUTATION = `
  mutation ScoreContent($input: ScoreContentInput!) {
    scoreContent(input: $input) { ${AI_CONTENT_SCORE_FIELDS} }
  }
`

const UPDATE_LLMS_TXT_MUTATION = `
  mutation UpdateLlmsTxt($input: UpdateLlmsTxtInput!) {
    updateLlmsTxt(input: $input) { ${LLMS_TXT_FIELDS} }
  }
`

const SYNC_EXTERNAL_TOOLS_MUTATION = `
  mutation SyncExternalAEOTools($input: ExternalToolSyncInput!) {
    syncExternalAEOTools(input: $input) {
      success
      recordsImported
      lastSyncAt
      errors
    }
  }
`

// ---------------------------------------------------------------------------
// GraphQL client (authenticated)
// ---------------------------------------------------------------------------

async function authGraphqlFetch<T>(
  query: string,
  variables: Record<string, unknown>,
  token: string,
): Promise<T> {
  const res = await fetch(API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ query, variables }),
    cache: 'no-store',
  })

  if (!res.ok) {
    throw new Error(`GraphQL request failed: ${res.status}`)
  }

  const json = await res.json()
  if (json.errors?.length) {
    throw new Error(json.errors[0].message)
  }
  return json.data
}

// ---------------------------------------------------------------------------
// In-memory mock stores for dev mode
// ---------------------------------------------------------------------------

let mockPrompts = [...SEED_PROMPTS]
let mockCitations = [...SEED_CITATIONS]
let mockVisibility = [...SEED_VISIBILITY]
let mockSchema = [...SEED_SCHEMA]
let mockContentScores = [...SEED_CONTENT_SCORES]
let mockLlmsTxt = { ...SEED_LLMS_TXT }
let mockCrawlerLogs = [...SEED_CRAWLER_LOGS]
let mockBenchmarks = [...SEED_COMPETITOR_BENCHMARKS]
let mockGaps = [...SEED_GAPS]

// ---------------------------------------------------------------------------
// CRUD: Prompt Tracking (BF-AE-004, BF-AE-007)
// ---------------------------------------------------------------------------

export async function fetchAllPrompts(
  token: string,
  limit = 100,
  offset = 0,
  filters?: { category?: PromptCategory; status?: PromptStatus },
): Promise<AIPrompt[]> {
  try {
    const data = await authGraphqlFetch<{ aiPrompts: AIPrompt[] }>(
      AI_PROMPTS_QUERY,
      { limit, offset, category: filters?.category, status: filters?.status },
      token,
    )
    return data.aiPrompts
  } catch {
    if (useSeedData()) {
      let result = mockPrompts
      if (filters?.category) result = result.filter((p) => p.category === filters.category)
      if (filters?.status) result = result.filter((p) => p.status === filters.status)
      return result.slice(offset, offset + limit)
    }
    return []
  }
}

export async function fetchPromptById(
  token: string,
  id: string,
): Promise<AIPrompt | null> {
  try {
    const data = await authGraphqlFetch<{ aiPromptById: AIPrompt }>(
      AI_PROMPT_BY_ID_QUERY,
      { id },
      token,
    )
    return data.aiPromptById
  } catch {
    if (useSeedData()) return mockPrompts.find((p) => p.id === id) || null
    return null
  }
}

export async function createPrompt(
  token: string,
  input: CreateAIPromptInput,
): Promise<AIPrompt> {
  if (useSeedData()) {
    const now = new Date().toISOString()
    const prompt: AIPrompt = {
      id: `seed-prompt-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
      text: input.text,
      category: input.category,
      estimatedVolume: input.estimatedVolume || 0,
      engines: ALL_AI_ENGINES.map((engine) => ({
        engine,
        lastChecked: now,
        afCited: false,
        afMentioned: false,
        afPosition: null,
        competitorsCited: [],
      })),
      priority: input.priority || 3,
      contentBriefId: null,
      status: input.status || 'TRACKING',
      createdAt: now,
      updatedAt: now,
    }
    mockPrompts = [prompt, ...mockPrompts]
    return prompt
  }

  const data = await authGraphqlFetch<{ createAIPrompt: AIPrompt }>(
    CREATE_AI_PROMPT_MUTATION,
    { input },
    token,
  )
  return data.createAIPrompt
}

export async function updatePrompt(
  token: string,
  id: string,
  input: UpdateAIPromptInput,
): Promise<AIPrompt> {
  if (useSeedData()) {
    const idx = mockPrompts.findIndex((p) => p.id === id)
    if (idx === -1) throw new Error('Prompt not found')
    const updated: AIPrompt = {
      ...mockPrompts[idx],
      ...(input.text !== undefined && { text: input.text }),
      ...(input.category !== undefined && { category: input.category }),
      ...(input.estimatedVolume !== undefined && { estimatedVolume: input.estimatedVolume }),
      ...(input.priority !== undefined && { priority: input.priority }),
      ...(input.status !== undefined && { status: input.status }),
      updatedAt: new Date().toISOString(),
    }
    mockPrompts[idx] = updated
    return updated
  }

  const data = await authGraphqlFetch<{ updateAIPrompt: AIPrompt }>(
    UPDATE_AI_PROMPT_MUTATION,
    { id, input },
    token,
  )
  return data.updateAIPrompt
}

export async function deletePrompt(
  token: string,
  id: string,
): Promise<void> {
  if (useSeedData()) {
    mockPrompts = mockPrompts.filter((p) => p.id !== id)
    return
  }

  await authGraphqlFetch<{ deleteAIPrompt: { id: string } }>(
    DELETE_AI_PROMPT_MUTATION,
    { id },
    token,
  )
}

/** Bulk wrapper: fetch, create, update, delete prompts. */
export async function trackPrompts(
  token: string,
  action: 'list' | 'create' | 'update' | 'delete',
  payload?: {
    id?: string
    input?: CreateAIPromptInput | UpdateAIPromptInput
    filters?: { category?: PromptCategory; status?: PromptStatus }
    limit?: number
    offset?: number
  },
): Promise<AIPrompt[] | AIPrompt | void> {
  switch (action) {
    case 'list':
      return fetchAllPrompts(token, payload?.limit, payload?.offset, payload?.filters)
    case 'create':
      return createPrompt(token, payload!.input as CreateAIPromptInput)
    case 'update':
      return updatePrompt(token, payload!.id!, payload!.input as UpdateAIPromptInput)
    case 'delete':
      return deletePrompt(token, payload!.id!)
  }
}

// ---------------------------------------------------------------------------
// CRUD: Citations (BF-AE-004)
// ---------------------------------------------------------------------------

export async function getCitations(
  token: string,
  filters?: { promptId?: string; engine?: AIEngine; brand?: string },
  limit = 100,
  offset = 0,
): Promise<AICitation[]> {
  try {
    const data = await authGraphqlFetch<{ aiCitations: AICitation[] }>(
      AI_CITATIONS_QUERY,
      { promptId: filters?.promptId, engine: filters?.engine, brand: filters?.brand, limit, offset },
      token,
    )
    return data.aiCitations
  } catch {
    if (useSeedData()) {
      let result = mockCitations
      if (filters?.promptId) result = result.filter((c) => c.promptId === filters.promptId)
      if (filters?.engine) result = result.filter((c) => c.engine === filters.engine)
      if (filters?.brand) result = result.filter((c) => c.brand === filters.brand)
      return result.slice(offset, offset + limit)
    }
    return []
  }
}

// ---------------------------------------------------------------------------
// CRUD: Visibility Snapshots (BF-AE-001)
// ---------------------------------------------------------------------------

export async function getVisibility(
  token: string,
  filters?: { engine?: AIEngine; startDate?: string; endDate?: string },
): Promise<AIVisibilitySnapshot[]> {
  try {
    const data = await authGraphqlFetch<{ aiVisibilitySnapshots: AIVisibilitySnapshot[] }>(
      AI_VISIBILITY_QUERY,
      { engine: filters?.engine, startDate: filters?.startDate, endDate: filters?.endDate },
      token,
    )
    return data.aiVisibilitySnapshots
  } catch {
    if (useSeedData()) {
      let result = mockVisibility
      if (filters?.engine) result = result.filter((v) => v.engine === filters.engine)
      if (filters?.startDate) result = result.filter((v) => v.date >= filters.startDate!)
      if (filters?.endDate) result = result.filter((v) => v.date <= filters.endDate!)
      return result
    }
    return []
  }
}

// ---------------------------------------------------------------------------
// CRUD: Share of Voice (BF-AE-006)
// ---------------------------------------------------------------------------

export async function getSOV(
  token: string,
  filters?: { engine?: AIEngine; startDate?: string; endDate?: string },
): Promise<AICompetitorBenchmark[]> {
  try {
    const data = await authGraphqlFetch<{ aiCompetitorBenchmarks: AICompetitorBenchmark[] }>(
      AI_SOV_QUERY,
      { engine: filters?.engine, startDate: filters?.startDate, endDate: filters?.endDate },
      token,
    )
    return data.aiCompetitorBenchmarks
  } catch {
    if (useSeedData()) {
      let result = mockBenchmarks
      if (filters?.engine) result = result.filter((b) => b.engine === filters.engine)
      if (filters?.startDate) result = result.filter((b) => b.date >= filters.startDate!)
      if (filters?.endDate) result = result.filter((b) => b.date <= filters.endDate!)
      return result
    }
    return []
  }
}

// ---------------------------------------------------------------------------
// CRUD: Prompt Gaps (BF-AE-007, BF-AE-012)
// ---------------------------------------------------------------------------

export async function getGaps(
  token: string,
  limit = 50,
  offset = 0,
): Promise<PromptGap[]> {
  try {
    const data = await authGraphqlFetch<{ aiPromptGaps: PromptGap[] }>(
      AI_GAPS_QUERY,
      { limit, offset },
      token,
    )
    return data.aiPromptGaps
  } catch {
    if (useSeedData()) return mockGaps.slice(offset, offset + limit)
    return []
  }
}

// ---------------------------------------------------------------------------
// CRUD: Schema Markup (BF-AE-002, BF-AE-016)
// ---------------------------------------------------------------------------

export async function fetchAllSchemaMarkups(
  token: string,
  limit = 100,
  offset = 0,
  filters?: { schemaType?: SchemaType; validationStatus?: SchemaValidationStatus },
): Promise<SchemaMarkup[]> {
  try {
    const data = await authGraphqlFetch<{ schemaMarkups: SchemaMarkup[] }>(
      SCHEMA_MARKUPS_QUERY,
      { schemaType: filters?.schemaType, validationStatus: filters?.validationStatus, limit, offset },
      token,
    )
    return data.schemaMarkups
  } catch {
    if (useSeedData()) {
      let result = mockSchema
      if (filters?.schemaType) result = result.filter((s) => s.schemaType === filters.schemaType)
      if (filters?.validationStatus) result = result.filter((s) => s.validationStatus === filters.validationStatus)
      return result.slice(offset, offset + limit)
    }
    return []
  }
}

export async function createSchemaMarkup(
  token: string,
  input: CreateSchemaMarkupInput,
): Promise<SchemaMarkup> {
  if (useSeedData()) {
    const now = new Date().toISOString()
    const schema: SchemaMarkup = {
      id: `seed-schema-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
      pageUrl: input.pageUrl,
      pageTitle: input.pageTitle,
      schemaType: input.schemaType,
      jsonLd: input.jsonLd,
      isAutoGenerated: input.isAutoGenerated || false,
      validationStatus: 'VALID',
      lastValidatedAt: now,
      injectedAt: null,
      createdAt: now,
      updatedAt: now,
    }
    mockSchema = [schema, ...mockSchema]
    return schema
  }

  const data = await authGraphqlFetch<{ createSchemaMarkup: SchemaMarkup }>(
    CREATE_SCHEMA_MARKUP_MUTATION,
    { input },
    token,
  )
  return data.createSchemaMarkup
}

export async function updateSchemaMarkup(
  token: string,
  id: string,
  input: UpdateSchemaMarkupInput,
): Promise<SchemaMarkup> {
  if (useSeedData()) {
    const idx = mockSchema.findIndex((s) => s.id === id)
    if (idx === -1) throw new Error('Schema not found')
    const updated: SchemaMarkup = {
      ...mockSchema[idx],
      ...(input.pageTitle !== undefined && { pageTitle: input.pageTitle }),
      ...(input.schemaType !== undefined && { schemaType: input.schemaType }),
      ...(input.jsonLd !== undefined && { jsonLd: input.jsonLd }),
      ...(input.validationStatus !== undefined && { validationStatus: input.validationStatus }),
      updatedAt: new Date().toISOString(),
    }
    mockSchema[idx] = updated
    return updated
  }

  const data = await authGraphqlFetch<{ updateSchemaMarkup: SchemaMarkup }>(
    UPDATE_SCHEMA_MARKUP_MUTATION,
    { id, input },
    token,
  )
  return data.updateSchemaMarkup
}

export async function deleteSchemaMarkup(
  token: string,
  id: string,
): Promise<void> {
  if (useSeedData()) {
    mockSchema = mockSchema.filter((s) => s.id !== id)
    return
  }

  await authGraphqlFetch<{ deleteSchemaMarkup: { id: string } }>(
    DELETE_SCHEMA_MARKUP_MUTATION,
    { id },
    token,
  )
}

/** Unified CRUD for schema markup management. */
export async function manageSchema(
  token: string,
  action: 'list' | 'create' | 'update' | 'delete',
  payload?: {
    id?: string
    input?: CreateSchemaMarkupInput | UpdateSchemaMarkupInput
    filters?: { schemaType?: SchemaType; validationStatus?: SchemaValidationStatus }
    limit?: number
    offset?: number
  },
): Promise<SchemaMarkup[] | SchemaMarkup | void> {
  switch (action) {
    case 'list':
      return fetchAllSchemaMarkups(token, payload?.limit, payload?.offset, payload?.filters)
    case 'create':
      return createSchemaMarkup(token, payload!.input as CreateSchemaMarkupInput)
    case 'update':
      return updateSchemaMarkup(token, payload!.id!, payload!.input as UpdateSchemaMarkupInput)
    case 'delete':
      return deleteSchemaMarkup(token, payload!.id!)
  }
}

// ---------------------------------------------------------------------------
// CRUD: Content Scoring (BF-AE-005)
// ---------------------------------------------------------------------------

export async function scoreContent(
  token: string,
  input: ScoreContentInput,
): Promise<AIContentScore> {
  if (useSeedData()) {
    await new Promise((resolve) => setTimeout(resolve, 800))

    const answerFirst = 50 + Math.floor(Math.random() * 50)
    const heading = 60 + Math.floor(Math.random() * 40)
    const conciseness = 55 + Math.floor(Math.random() * 45)
    const schemaPresence = 40 + Math.floor(Math.random() * 60)
    const listTable = 45 + Math.floor(Math.random() * 55)
    const eeat = 40 + Math.floor(Math.random() * 50)
    const overall = Math.round(
      (answerFirst + heading + conciseness + schemaPresence + listTable + eeat) / 6,
    )

    const improvements: ScoreImprovement[] = []
    if (answerFirst < 70) improvements.push({ dimension: 'answerFirst', suggestion: 'Move the primary answer to the first paragraph for better AI extraction' })
    if (heading < 70) improvements.push({ dimension: 'headingHierarchy', suggestion: 'Ensure semantic H2/H3 hierarchy without skipping levels' })
    if (conciseness < 70) improvements.push({ dimension: 'conciseness', suggestion: 'Keep paragraphs between 40-60 words for optimal AI readability' })
    if (schemaPresence < 70) improvements.push({ dimension: 'schemaPresence', suggestion: 'Add FAQPage or HowTo schema markup to this content' })
    if (listTable < 70) improvements.push({ dimension: 'listTable', suggestion: 'Add numbered steps or comparison tables for structured data extraction' })
    if (eeat < 70) improvements.push({ dimension: 'eeat', suggestion: 'Include author byline with credentials, citations, and original data' })

    const score: AIContentScore = {
      id: `seed-score-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
      contentId: input.contentId,
      contentType: input.contentType,
      overallScore: overall,
      answerFirstScore: answerFirst,
      headingHierarchyScore: heading,
      concisenessScore: conciseness,
      schemaPresenceScore: schemaPresence,
      listTableScore: listTable,
      eeatScore: eeat,
      improvements,
      scoredAt: new Date().toISOString(),
    }
    mockContentScores = [score, ...mockContentScores]
    return score
  }

  const data = await authGraphqlFetch<{ scoreContent: AIContentScore }>(
    SCORE_CONTENT_MUTATION,
    { input },
    token,
  )
  return data.scoreContent
}

export async function fetchContentScores(
  token: string,
  limit = 50,
  offset = 0,
  filters?: { contentType?: AIContentType },
): Promise<AIContentScore[]> {
  try {
    const data = await authGraphqlFetch<{ aiContentScores: AIContentScore[] }>(
      AI_CONTENT_SCORES_QUERY,
      { contentType: filters?.contentType, limit, offset },
      token,
    )
    return data.aiContentScores
  } catch {
    if (useSeedData()) {
      let result = mockContentScores
      if (filters?.contentType) result = result.filter((s) => s.contentType === filters.contentType)
      return result.slice(offset, offset + limit)
    }
    return []
  }
}

// ---------------------------------------------------------------------------
// CRUD: llms.txt Management (BF-AE-003)
// ---------------------------------------------------------------------------

export async function fetchLlmsTxt(
  token: string,
  siteUrl?: string,
): Promise<LlmsTxt | null> {
  try {
    const data = await authGraphqlFetch<{ llmsTxt: LlmsTxt }>(
      LLMS_TXT_QUERY,
      { siteUrl },
      token,
    )
    return data.llmsTxt
  } catch {
    if (useSeedData()) return { ...mockLlmsTxt }
    return null
  }
}

export async function updateLlmsTxt(
  token: string,
  input: UpdateLlmsTxtInput,
): Promise<LlmsTxt> {
  if (useSeedData()) {
    const now = new Date().toISOString()
    const linkCount = (input.content.match(/\[.*?\]\(.*?\)/g) || []).length
    mockLlmsTxt = {
      ...mockLlmsTxt,
      content: input.content,
      siteUrl: input.siteUrl || mockLlmsTxt.siteUrl,
      linkCount,
      lastUpdatedAt: now,
      updatedAt: now,
    }
    return { ...mockLlmsTxt }
  }

  const data = await authGraphqlFetch<{ updateLlmsTxt: LlmsTxt }>(
    UPDATE_LLMS_TXT_MUTATION,
    { input },
    token,
  )
  return data.updateLlmsTxt
}

/** Unified read/write for llms.txt. */
export async function manageLlmsTxt(
  token: string,
  action: 'get' | 'update',
  payload?: { input?: UpdateLlmsTxtInput; siteUrl?: string },
): Promise<LlmsTxt | null> {
  switch (action) {
    case 'get':
      return fetchLlmsTxt(token, payload?.siteUrl)
    case 'update':
      return updateLlmsTxt(token, payload!.input!)
  }
}

// ---------------------------------------------------------------------------
// CRUD: Crawler Logs (BF-AE-003)
// ---------------------------------------------------------------------------

export async function getCrawlerLogs(
  token: string,
  filters?: { userAgent?: AICrawlerBot },
  limit = 100,
  offset = 0,
): Promise<AICrawlerLog[]> {
  try {
    const data = await authGraphqlFetch<{ aiCrawlerLogs: AICrawlerLog[] }>(
      AI_CRAWLER_LOGS_QUERY,
      { userAgent: filters?.userAgent, limit, offset },
      token,
    )
    return data.aiCrawlerLogs
  } catch {
    if (useSeedData()) {
      let result = mockCrawlerLogs
      if (filters?.userAgent) result = result.filter((l) => l.userAgent === filters.userAgent)
      return result.slice(offset, offset + limit)
    }
    return []
  }
}

// ---------------------------------------------------------------------------
// External Tool Sync (BF-AE-013)
// ---------------------------------------------------------------------------

export interface ExternalSyncResult {
  success: boolean
  recordsImported: number
  lastSyncAt: string
  errors: string[]
}

export async function syncExternalTools(
  token: string,
  input: ExternalToolSyncInput,
): Promise<ExternalSyncResult> {
  if (useSeedData()) {
    await new Promise((resolve) => setTimeout(resolve, 2000))

    const recordCounts: Record<string, number> = {
      PROFOUND: 150 + Math.floor(Math.random() * 100),
      SEMRUSH: 200 + Math.floor(Math.random() * 150),
      AHREFS: 300 + Math.floor(Math.random() * 200),
    }

    return {
      success: true,
      recordsImported: recordCounts[input.platform],
      lastSyncAt: new Date().toISOString(),
      errors: [],
    }
  }

  const data = await authGraphqlFetch<{ syncExternalAEOTools: ExternalSyncResult }>(
    SYNC_EXTERNAL_TOOLS_MUTATION,
    { input },
    token,
  )
  return data.syncExternalAEOTools
}

// ---------------------------------------------------------------------------
// Aggregate helpers
// ---------------------------------------------------------------------------

/** Compute AF's aggregate share of voice across all engines for a date range. */
export async function getAggregateSOV(
  token: string,
  startDate?: string,
  endDate?: string,
): Promise<{ afSOV: number; competitors: Array<{ name: string; sov: number }> }> {
  const benchmarks = await getSOV(token, { startDate, endDate })
  const visibility = await getVisibility(token, { startDate, endDate })

  if (useSeedData() && visibility.length > 0) {
    const afAvgSOV =
      visibility.reduce((sum, v) => sum + v.shareOfVoice, 0) / visibility.length

    const competitorMap = new Map<string, number[]>()
    for (const b of benchmarks) {
      const arr = competitorMap.get(b.competitorName) || []
      arr.push(b.shareOfVoice)
      competitorMap.set(b.competitorName, arr)
    }

    const competitors = Array.from(competitorMap.entries())
      .map(([name, vals]) => ({
        name,
        sov: vals.reduce((s, v) => s + v, 0) / vals.length,
      }))
      .sort((a, b) => b.sov - a.sov)

    return { afSOV: afAvgSOV, competitors }
  }

  return { afSOV: 0, competitors: [] }
}

/** Get availability status for each AI engine's monitoring API. */
export async function getEngineAvailability(): Promise<AvailabilitySlot[]> {
  return ALL_AI_ENGINES.map((engine) => ({
    engine,
    available: Math.random() > 0.1,
    lastChecked: new Date().toISOString(),
    rateLimitRemaining: Math.floor(Math.random() * 1000) + 500,
    dailyQuota: engine === 'CHATGPT' ? 10000 : engine === 'PERPLEXITY' ? 5000 : 1000,
    dailyUsed: Math.floor(Math.random() * 500),
  }))
}

// ---------------------------------------------------------------------------
// Re-export seed data for use in mock mode
// ---------------------------------------------------------------------------

export {
  SEED_PROMPTS,
  SEED_CITATIONS,
  SEED_VISIBILITY,
  SEED_SCHEMA,
  SEED_LLMS_TXT,
  SEED_CONTENT_SCORES,
  SEED_CRAWLER_LOGS,
  SEED_COMPETITOR_BENCHMARKS,
  SEED_GAPS,
}
